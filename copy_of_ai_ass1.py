# -*- coding: utf-8 -*-
"""Copy of AI_Ass1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b27Fc030I2cJ6YqTOCOkXvIUMOhQWpYh
"""

import copy 
inf = float("inf")

class TSP:
	def __init__(self,city,source,n):
		self.city = city
		self.source = source   
		self.n = n 

	def solve(self):
		min_cost = inf
		for i in range(self.n):
			print("Path",end='')
			cost = self._solve(copy.deepcopy(self.city),i,i)
			print(f" --> {i} : Cost = {cost}")
			if min_cost>cost:
				min_cost = cost 
		return min_cost

	def _solve(self,city,source,curr_city):
		print(f" --> {curr_city} ",end='')
		for i in range(self.n):
			city[i][curr_city] = inf   

		min_cost,minPos = inf,0  
		for i in range(self.n):
			if city[curr_city][i]<min_cost:
				min_cost = city[curr_city][i]
				minPos = i  

		if min_cost==inf:
			return self.city[curr_city][source]

		city[curr_city][minPos] = city[minPos][curr_city] = inf 
		return min_cost + self._solve(city,source,minPos)




if __name__=="__main__":
	city_matrix = [
	                [inf, 10, 15, 20],
	                [10, inf, 35, 25],
	                [15, 35, inf, 30],
	                [20, 25, 30, inf]]
	source = 0 
	tsp = TSP(city_matrix,source,4)
	print(f"Optimal Cost --> {tsp.solve()} ")

def Hanoi(n,source,auxillary,destination):
	count = 1 
	if n==1:
		print(f"Move from {source} to {destination}")
		return count 
	count+=Hanoi(n-1,source,destination,auxillary)
	print(f"Move from {source} to {destination}")
	count+=Hanoi(n-1,auxillary,source,destination)
	return count 


Hanoi(3,'A','B','C')

import random 

n = 8
MAX = float("inf")
board = [[0]*n for _ in range(n)]
neighbours = [[0]*n for _ in range(n)]
queens = [0]*n   

def collision_count(r,c,n):
	collisions = 0
	directions = [[0,1],[1,0],[-1,0],[0,-1],[-1,-1],[1,1],[-1,1],[1,-1]]
	for dx,dy in directions:
		x,y = r+dx,c+dy  
		while(0<=x<n and 0<=y<n):
			if board[x][y]==1:
				collisions+=1 
			x+=dx  
			y+=dy  
	return collisions

def total_collisions(n):
	total = 0
	for i in range(n):
		total+=collision_count(i,queens[i],n)
	return total 

limit = 10

while(limit>0):
	print("\nRandom Start\n")
	for i in range(n):
		queens[i] = random.randrange(0,n)
		board[i][queens[i]] = 1  

	total = total_collisions(n)

	inner_limit = 10
	while(inner_limit>0):
		print(" ".join(map(str,queens)))

		for i in range(n):
			prev_queen = queens[i]
			board[i][prev_queen] = 0
			for j in range(n):
				queens[i] = j  
				board[i][j] = 1
				neighbours[i][j] = total_collisions(n)
				board[i][j] = 0
			queens[i] = prev_queen
			board[i][prev_queen] = 1 

		min_collisions = MAX
		min_row,min_col = -1,-1 
		for i in range(n):
			for j in range(n):
				if min_collisions>neighbours[i][j]:
					min_collisions,min_row,min_col = neighbours[i][j],i,j 

		if min_collisions<total:
			board[min_row][queens[min_row]] = 0 
			queens[min_row] = min_col
			total = min_collisions  

		else:
			break
		inner_limit-=1 

	if total==0:
		print("\nGlobal Minimum Reached")
		break 

	limit-=1

